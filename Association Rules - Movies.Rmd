---
title: "Association Rules - Movies"
author: "Roberto Baca"
date: "08/08/2025"
output: 
  prettydoc::html_pretty:
          theme: hpstr
---

# Association Rules: Movie Recommendation Model (Netflix)

The objective of this project is to apply association rules using R to build a movie recommendation model based on user behavior.

The MovieLens (ml-latest-small) dataset, sourced from a movie recommendation service, will be used. This dataset contains 100,836 ratings for 9,742 movies.

The data was generated by 609 users between March 1996 and September 2018. All selected users rated at least 20 movies. No demographic information is included; each user is identified solely by an ID.

For the development of the model:

* Movies rated with 4 stars or higher will be filtered, considering only those with a positive evaluation.

* The Apriori algorithm (association rules) will then be applied to identify frequent co-viewing patterns among movies.

* Finally, the model will generate recommendations of up to 5 new titles for each user, based on their previous selections.

This approach allows for the generation of personalized recommendations without the need for demographic data, relying exclusively on behavioral patterns observed in the ratings.

## ETL: Extract, Transform and Load

```{r}
# load the dataset
ratings <- read.csv("https://raw.githubusercontent.com/roberbaca/association-rules-movies/refs/heads/main/data/ratings.csv")
movies <- read.csv("https://raw.githubusercontent.com/roberbaca/association-rules-movies/refs/heads/main/data/movies.csv")
```

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(knitr)

#merge the tables
movie_df <- merge(ratings, movies, by="movieId")

# filter the movies rated with 4 or more stars
movie_df_filtered <- subset(movie_df, rating >= 4)

# drop timestamp column
movie_df_filtered <- select(movie_df_filtered, -timestamp)

kable(head(movie_df_filtered))

```

```{r}
str(movie_df_filtered)
```

```{r}
# unique users
length(unique(movie_df_filtered$userId))

# movies with rating â‰¥ 4 stars
length(unique(movie_df_filtered$title))
```

## Conversion to transactions

```{r warning=FALSE, message=FALSE}
library(arules)

# create a list of movies per user
user_lists <- split(movie_df_filtered$title, movie_df_filtered$userId)

# convert to transactions
movie_transactions <- as(user_lists, "transactions")

# inspect the second transaction for verification
inspect(movie_transactions[2])

```
## Frequencies

```{r}
# Top 5 most-watched movies
itemFrequencyPlot(movie_transactions, topN = 5, type = "relative", col = "steelblue", cex.names = 0.7, ylab = "Relative Frequency", main = "Movies most watched")
```
```{r}
Frequencies <- (head(sort(itemFrequency(movie_transactions), decreasing = TRUE),5))
Frequencies <- round(Frequencies, 2)
tabla <- as.data.frame(Frequencies)
kable(tabla)
```

## Rule generation with Apriori

* Support: How frequently an itemset appears in all transactions (how many times the entire rule appears).

* Confidence: The probability that the item(s) on the right-hand side (consequent) occur given that the left-hand side (antecedent) has occurred.

* Lift: Measures how much more likely the consequent is to occur together with the antecedent compared to occurring separately (by chance).

* Coverage: How many times the antecedent (LHS) appears in the data.


We applied the following parameters:

* At least 3% of users must have rated a given movie combination for it to be considered.
* The probability that a user who watches the left-hand side of the rule also watches the right-hand side must be 60%.
* The maximum length of a rule is 4 items.


```{r warning=FALSE, message=FALSE}
rules <- apriori(movie_transactions, parameter = list(supp = 0.03, conf = 0.6, minlen = 2, maxlen = 4))

summary(rules)

```

```{r}
# filter the best rules
top_rules <- head(sort(rules, by = "lift"), 5)
inspect(top_rules)
```



## Visualization of association rules

The relationships can be displayed graphically using a network-type (graph) visualization of the association rules.

```{r warning=FALSE, message=FALSE}
library(arulesViz)

plot(top_rules, method = "graph", engine = "htmlwidget")
```


A Support vs. Confidence scatter plot visualization can also be used.

```{r}
# Scatter plot of rules (Support vs. Confidence, shaded by Lift)

# Retain the rules with the highest lift
rules_subset <- head(sort(rules, by = "lift"), 300000)

# Plot the results
plot(rules_subset, measure=c("support", "confidence"), shading="lift", jitter = 0.1, main="Soporte vs Confianza")
```

## Movie recommendation model

```{r}
library(arules)

# Function to recommend movies

recomendar_peliculas <- function(rules, user_movies, n = 10) {
  # Filter the rules where all items on the left-hand side are in user_movies
  reglas_usuario <- subset(rules, lhs %ain% user_movies)
  
  # If no applicable rules are found, return a message
  if (length(reglas_usuario) == 0) {
    cat("No se encontraron reglas aplicables para este usuario.\n")
    return(character(0))
  }

  # Sort the rules by lift in descending order (strongest first)
  reglas_ordenadas <- sort(reglas_usuario, by = "lift", decreasing = TRUE)
  
  # Extract the recommended movies (right-hand side) from the rules sorted by lift
  recomendadas_ordenadas <- unique(unlist(LIST(rhs(reglas_ordenadas), decode = TRUE)))
  
  # Remove movies already watched by the user
  recomendadas_ordenadas <- setdiff(recomendadas_ordenadas, user_movies)

  # Return only the first n recommendations
  head(recomendadas_ordenadas, n)

}
```


The script below simulates a new user (not present in the original dataset) who indicates that they liked certain movies, and the system searches for rules where the left-hand side (LHS) matches those movies.

Then, it returns movies on the right-hand side (RHS) as recommendations, ordered according to lift (which measures the strength of the association).


```{r}
# List of movies watched by the user
user_movies <- c("Avengers, The (2012)")

# Obtain recommendations
recomendaciones <- recomendar_peliculas(rules, user_movies, n = 3)

# Print them numbered
cat("Movies watched by the user:", user_movies, "\n")

cat("Recommended movies:", "\n")
for (i in 1:length(recomendaciones)) {
    cat("[",i,"]", recomendaciones[i], "\n")
}

```


```{r}
user_movies <- c("Lion King, The (1994)", "Toy Story (1995)")

recomendaciones <- recomendar_peliculas(rules, user_movies, n = 3)

cat("Movies watched by the user:", user_movies, "\n")

cat("Recommended movies:", "\n")
for (i in 1:length(recomendaciones)) {
    cat("[",i,"]", recomendaciones[i], "\n")
}

```




```{r}
user_movies <- c("Alien (1979)", "Predator (1987)", "Terminator, The (1984)")

recomendaciones <- recomendar_peliculas(rules, user_movies, n = 3)

cat("Movies watched by the user:", user_movies, "\n")

cat("Recommended movies:", "\n")
for (i in 1:length(recomendaciones)) {
    cat("[",i,"]", recomendaciones[i], "\n")
}

```


```{r echo=FALSE, eval=FALSE}
library(shiny)
library(arules)

peliculas_disponibles <- unique(items(movie_transactions)@itemInfo$labels)

# FunciÃ³n de recomendaciÃ³n
recomendar_peliculas <- function(rules, user_movies, n = 10, criterio = "lift") {
  reglas_usuario <- subset(rules, lhs %ain% user_movies)
  
  if (length(reglas_usuario) == 0) {
    return(data.frame(Recomendacion = "No se encontraron recomendaciones."))
  }

  reglas_ordenadas <- switch(
    criterio,
    "lift" = sort(reglas_usuario, by = "lift", decreasing = TRUE),
    "confidence" = sort(reglas_usuario, by = "confidence", decreasing = TRUE),
    reglas_usuario
  )

  recomendaciones_df <- as(reglas_ordenadas, "data.frame")
  recomendaciones_df$lhs <- labels(lhs(reglas_ordenadas))
  recomendaciones_df$rhs <- labels(rhs(reglas_ordenadas))

  recomendaciones_df <- subset(recomendaciones_df, !(rhs %in% user_movies))
  recomendaciones_df <- recomendaciones_df[!duplicated(recomendaciones_df$rhs), ]
  recomendaciones_df <- head(recomendaciones_df, n)

  if (nrow(recomendaciones_df) == 0) {
    return(data.frame(Recomendacion = "No se encontraron recomendaciones."))
  }

  return(recomendaciones_df[, c("lhs", "rhs", "support", "confidence", "lift")])
}

# UI
ui <- fluidPage(
  titlePanel("ðŸŽ¬ Recomendador de PelÃ­culas (Apriori)"),
  
  sidebarLayout(
    sidebarPanel(
      selectizeInput("peliculas_usuario", 
                     "PelÃ­culas que te gustaron:",
                     choices = NULL,
                     multiple = TRUE,
                     options = list(
                       placeholder = 'EscribÃ­ para buscar pelÃ­culas...',
                       maxOptions = 10
                     )
      ),
      radioButtons("criterio", "Criterio de recomendaciÃ³n:",
                   choices = c("Lift" = "lift", "Confianza" = "confidence"),
                   selected = "lift"),
      numericInput("n_recomendaciones", "Cantidad de recomendaciones:", value = 5, min = 1, max = 20),
      actionButton("btn_recomendar", "ðŸŽ¥ Recomendar")
    ),
    
    mainPanel(
      h4("PelÃ­culas recomendadas:"),
      tableOutput("tabla_recomendaciones")
    )
  )
)

# Server
server <- function(input, output, session) {
  
  # Carga dinÃ¡mica de pelÃ­culas al input
  updateSelectizeInput(session, "peliculas_usuario",
                       choices = peliculas_disponibles,
                       server = TRUE)

  recomendaciones <- eventReactive(input$btn_recomendar, {
    req(input$peliculas_usuario)
    user_movies <- input$peliculas_usuario
    recomendar_peliculas(rules, user_movies, input$n_recomendaciones, input$criterio)
  })

  output$tabla_recomendaciones <- renderTable({
    recomendaciones()
  })
}

# Correr la app
shinyApp(ui = ui, server = server)


```

